<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Hâ‚‚</title>
<link rel="stylesheet" href="doc.css">
</head>
<body>

<h1>H<sub>2</sub></h1>

<article>
	<h1>Pages</h1>

	<p>Pages subserver is the default subserver which serves pages creating them from templates. Templates are stored in the "pages" directory of the application directory.</p>

	<p>The URL path is mapped to the directories hierarchy inside the pages directory. If the request is /foo/bar, then the subserver will try to parse files pages/foo/bar.php, pages/foo/default.php, pages/foo.php, pages/default.php until one of them is found.</p>

	<p>The trailing part of the URL will then be converted to the "arguments" accessible through the argv function. For example, if the request /foo/bar has resulted in the file pages/foo/default.php being called, then the arguments will be "default", "bar".</p>

	<article class="command">
		<h1>The <code>add_link</code> function</h1>

		<p class="disp"><code>add_link(<var>$rel</var>, <var>$href</var>)</code></p>

		<p>The <code>add_link</code> function adds a <code>&lt;link&gt;</code> element to the head section of the page, with <code>rel</code> and <code>href</code> attributes set to the given values.</p>
	</article>

	<article class="command">
		<h1>add_js</h1>
		<p><code>add_js($path)</code></p>
		<p>The add_js function adds a reference to a JavaScript file. The path must be relative to the site root. References are added as &lt;script&gt; tags with the "src" attribute set to the URL inferred from the given path. The tags are added at the end of the page, before the closing &lt;/body&gt; tag.</p>
	</article>

	<article class="command">
		<h1>The <code>add_css</code> function</h1>

		<p class="disp"><code>add_css(<var>$path</var>, ...)</code></p>

		<p>The <code>add_css</code> function adds references to given stylesheets.</p>

		<p>The given paths must be relative to the site root. Paths may have query strings (<code>?name=val&amp;...</code>).</p>

		<p>The references are added as <code>link</code> tags in the <code>head</code> section of the generated page. The function may be called at any time during the generation of the page.</p>
	</article>
</article>

<article>
	<h1>Actions subserver</h1>

	<article class="command">
		<h1>The <code>declare_action</code> function</h1>

		<p class="disp"><code>declare_action(<var>$name</var>, <var>$users</var>, <var>$func</var>)</code></p>

		<p>The <code>declare_action</code> function declares an action <var>name</var> and assigns <var>func</var> is the action function and <var>users</var> as the list of types of uses who can call that action.</p>

		<p>The <var>users</var> variable should contain a comma-separated list of user types. If <code>all</code> is given, all user types will have access to the action.</p>
	</article>
</article>

<article>
	<h1>Core</h1>

	<article class="command" id="poparg">
		<h1>The <code>poparg</code> function</h1>

		<p class="disp"><code><var>$arg</var> = poparg()</code></p>

		<p>The <code>poparg</code> function returns next part of the parsed URL and shifts the base pointer one step further. If there are no more parts, <code>poparg</code> returns <code>null</code>.</p>
	</article>

	<article>
		<h1>Subservers</h1>

		<p>The core takes requests from the web server and dispatches them to its own "subservers". A "subserver" is a function which takes a request object, determines if it can fulfil it, and if it can, fulfils is.</p>

		<p>The script will call all registered subserver functions in the order of their registration until one of them returns <code>true</code> or there are no more functions to call.</p>

		<p>The core itself defines a "pages" subserver which will be called last and will try to serve a page by from the "pages" directory.</p>

		<article class="command">
			<h1>The <code>add_subserver</code> function</h1>

			<p><code>add_subserver($func)</code></p>

			<p>The <code>add_subserver</code> function adds the function <var>func</var> to a list of request processing functions. The <var>func</var> function must have form:</p>

			<p><code>$ok = $func($request)</code>.</p>

			<p>If the function <var>func</var> will be called, it will receive a request object <var>request</var> and will have to determine whether to process it. If the function recognises the request and processes it, it must return <code>true</code>.</p>


		</article>
	</article>
</article>

<article>
	<h1>Library</h1>
	<article>
		<h1>Output</h1>

		<article class="command">
			<h1>The <code>redirect</code> function</h1>

			<p><code>redirect($url)</code></p>

			<p>The <code>redirect</code> function writes appropriate HTTP headers to the output to redirect the browser to the given URL. The script execution is stopped after that.</p>
		</article>

		<article class="command">
			<h1>The error_* functions</h1>

			<p><code>error_&lt;<i>type</i>&gt;()</code></p>

			<p>The error_* functions output corresponding HTTP status header and error page.</p>

			<table>
				<tr>
					<th>Function</th>
					<th>HTTP&nbsp;code</th>
					<th>Meaning</th>
				</tr>
				<tr>
					<td><code>error_bad_request</code></td>
					<td>400</td>
					<td></td>
				</tr>
				<tr>
					<td>error_forbidden</td>
					<td>403</td>
					<td>Access denied. The client probably has to login.</td>
				</tr>
				<tr>
					<td>error_notfound</td>
					<td>404</td>
					<td>Could not find the requested page.</td>
				</tr>
				<tr>
					<td>error_gone</td>
					<td>410</td>
					<td>The page was removed.</td>
				</tr>
				<tr>
					<td>error_server</td>
					<td>500</td>
					<td>We screwed up.</td>
				</tr>
			</table>
		</article>

		<article class="command">
			<h1>announce_*</h1>
			announce_json($charset='UTF-8')
			announce_txt($charset='UTF-8')
			announce_html($charset='UTF-8')
		</article>

		<article class="command">
			<h1>announce_file</h1>
			<p><code>announce_file($filename, $size=null)</code></p>
		</article>
	</article>

	<article>
		<h1>Errors and logging</h1>

		<article class="command" id="on_error">
			<h1>The <code>on_error</code> function</h1>

			<p class="disp"><code>on_error(<var>$func</var>)</code></p>

			<p>The <code>on_error</code> function adds the given function <var>$func</var> to the list of functions called when errors occur. The last added function will be called first.</p>

			<p>The function <var>func</var> must have form:</p>

			<p class="disp"><code><var>$ok</var> = <var>$func</var>(<var>$msg</var>, <var>$line</var>)</code></p>

			<p class="cont">where <var>$msg</var> is an error message and <var>$line</var> is a string in form "&lt;file&nbsp;path&gt;:&lt;line&nbsp;number&gt;" specifying the line where the error occured.</p>

			<p>If <var>$func</var> returns <code>true</code>, the rest of the error functions will not be called.</p>
		</article>

		<article class="command">
			<h1>error</h1>
			<p><code>error($message)</code></p>
			<p>Writes a message to the log and stops the execution. The browser will receive an "Internal server error" response.</p>
		</article>

		<article class="command">
			<h1>warning</h1>
			<p><code>warning($message)</code></p>
			<p>Writes the message to the log. Intended to mark potential errors.</p>
		</article>

		<article class="command">
			<h1>log_message</h1>
		</article>
	</article>

	<article>
		<h1>Loading components</h1>

		<article class="command">
			<h1>lib</h1>

			<p><code>lib($name)</code></p>
			<p>The lib function includes the file $name.php in the application's lib directory. This is a way to declaratively include libraries, typically used in application init scripts.</p>
		</article>

		<article class="command">
			<h1>add_classes_dir</h1>
			<p><code>add_classes_dir($dir)</code></p>
			<p>Adds the given directory to the list of directories searched by the classes autoloader.</p>
		</article>

		<article class="command" id="load_ext">
			<h1>The <code>load_ext</code> function</h1>

			<p class="disp"><code>load_ext(<var>$name</var>, ...)</code></p>

			<p>The <code>load_ext</code> function is similar to the <code>lib</code> function except the libraries are loaded from the extensions directory of the H<sub>2</sub> distribution.</p>

			<p>The extensions are different from libraries in that they interact with H<sub>2</sub> API.</p>
		</article>
	</article>

	<article>
		<h1>Debugging</h1>
		<article class="command">
			<h1>e</h1>
		</article>

		<article class="command">
			<h1>ob_destroy</h1>
		</article>

		<article class="command">
			<h1>msg</h1>
		</article>

		<article class="command">
			<h1>debug</h1>
		</article>
	</article>

	<article>
		<h1>Configuration</h1>

		<article class="command">
			<h1>setting</h1>
		</article>
	</article>

	<article>
		<h1>Request data</h1>
		<article class="command">
			<h1>vars::get</h1>
		</article>

		<article class="command">
			<h1>vars::post</h1>
		</article>

		<article class="command">
			<h1>vars::posts</h1>
		</article>
	</article>

	<article id="uploads">
		<h1>File uploads</h1>

		<article class="command" id="uploaded_files">
			<h1>The <code>uploaded_files</code> function</h1>

			<p class="disp"><code><var>$files</var> = uploaded_files(<var>$input_name</var>)</code></p>

			<p>The <code>uploaded_files</code> function returns descriptions of uploaded files stored in the <code>$_FILES</code> global array under the index <var>$input_name</var>, converting the single-file case to the general multiple-files form. Each element of the <var>$files</var> array is an associative array with fields <code>name</code>, <code>type</code>, <code>tmp_name</code>, <code>size</code> and <code>error</code>.</p>
		</article>

		<article class="command" id="accept_uploads">
			<h1>The <code>accept_uploads</code> function</h1>

			<p class="disp"><code><var>$paths</var> = accept_uploads(<var>$input_name</var>, <var>$dirpath</var>)</code></p>

			<p>The <code>accept_uploads</code> function processes the uploaded files using <var>$input_name</var> as index to the <code>$_FILES</code> global array, moves all uploaded files to the directory <var>$dirpath</var> assigning them random names and returns an array of paths to the new files.</p>
		</article>
	</article>

	<article>
		<h1>Writing files</h1>

		<article class="command">
			<h1><code>files::save</code></h1>

			<p class="disp"><code><var>$ok</var> = files::save(<var>$dir</var>, <var>$name</var>, <var>$contents</var>)</code></p>

			<p>Saves given contents to the file named <var>$name</var> in the directory <var>$dir</var>.</p>
		</article>

		<article class="command">
			<h1>files::get</h1>
		</article>

		<article class="command">
			<h1>files::append</h1>
		</article>

		<article class="command">
			<h1>files::time</h1>
		</article>
	</article>

	<article>
		<h1>Sessions</h1>

		<article class="command">
			<h1>user::auth</h1>
		</article>

		<article class="command">
			<h1>user::get_type</h1>
		</article>

		<article class="command">
			<h1>user::get_id</h1>
		</article>

		<article class="command">
			<h1>user::set_data</h1>
		</article>

		<article class="command">
			<h1>user::get_data</h1>
		</article>
	</article>

</article>

<article>
	<h1>Configuration parameters</h1>

	Constants
	APP_DIR
	WRITE_DIR
	SITE_ROOT


	<table class="dl">
		<tr>
			<th>Parameter</th>
			<th>Default</th>
			<th>Description</th>
		</tr>

		<tr>
			<td>debug</td>
			<td>0</td>
			<td>Set to 1 to enable debugging checks. This will affect every function that checks for return value of the debug function. In particular, warnings will be treated as errors.</td>
		</tr>


		<tr>
			<td>log_actions</td>
			<td>0</td>
			<td>Set to 1 to make the actions subserver write all successful actions to a log file.</td>
		</tr>

		<tr>
			<td>mysql_host</td>
			<td>localhost</td>
			<td></td>
		</tr>
		<tr>
			<td>mysql_user</td>
			<td></td>
			<td></td>
		</tr>
	</table>

</article>

<section id="extensions">
	<h1>Extensions</h1>

	<article id="ext_debug">
		<h1>The <code>ext_debug</code> extension</h1>

		<p>The <code>ext_debug</code> extension catches all errors and outputs execution stacks terminating the script. It does nothing if the <code>debug</code> parameter is not set to <code>1</code>.</p>
	</article>
</section>

<script src="toc.js?auto-id"></script>

</body>
</html>
