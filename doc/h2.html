<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>H2</title>
<link rel="stylesheet" href="doc.css">
</head>
<body>
	
<h1>H2</h1>

<article>
	<h1>Core</h1>
	
	<article>
		<h1>Subservers</h1>

		<p>The core defines a "server" which takes requests from the actual web server and dispatches them to "subservers". It contains functionality sufficient to respond to requests and produce output, but lacks the actual subservers. The core also includes commonly used functions.</p>

		<article class="command">
			<h1>add_subserver</h1>

			<p><code>add_subserver($func)</code></p>

			<p>The add_subserver function adds the given function to a list of functions called to process each request. The function will receive a request object and will have to determine whether to process it. If the subserver function recognises the request and servies it, it must return true.</p>

			<p>The server will call all registered subserver function in the order of their registration until one of them returns true.</p>
		</article>
	</article>
	
	<article>
		<h1>Output</h1>
		
		<article class="command">
			<h1>redirect</h1>
			<p><code>redirect($url)</code></p>
			<p>The redirect function writes a "Location" header to the response to redirect the browser to the given URL. The current execution is stopped.</p>
		</article>
		
		<article class="command">
			<h1>error_*</h1>
			<p><code>error_&lt;type&gt;()</code></p>
			<p>The error_* functions are a set of shortcuts to output a HTTP status header and show an error page.</p>
			<table>
				<tr>
					<td>error_bad_request</td>
					<td>400</td>
				</tr>
				<tr>
					<td>error_forbidden</td>
					<td>403</td>
				</tr>
				<tr>
					<td>error_notfound</td>
					<td>404</td>
				</tr>
				<tr>
					<td>error_gone</td>
					<td>410</td>
				</tr>
				<tr>
					<td>error_server</td>
					<td>500</td>
				</tr>
			</table>
		</article>
	
		<article class="command">
			<h1>announce_*</h1>
			announce_json($charset='UTF-8')
			announce_txt($charset='UTF-8')
			announce_html($charset='UTF-8')
		</article>
		
		<article class="command">
			<h1>announce_file</h1>
			<p><code>announce_file($filename, $size=null)</code></p>
		</article>
	</article>
	
	<article>
		<h1>Errors and logging</h1>
		
		<article class="command">
			<h1>on_error</h1>
		</article>

		<article class="command">
			<h1>error</h1>
			<p><code>error($message)</code></p>
			<p>Writes a message to the log and stops the execution. The browser will receive an "Internal server error" response.</p>
		</article>

		<article class="command">
			<h1>warning</h1>
			<p><code>warning($message)</code></p>
			<p>Writes the message to the log. Intended to mark potential errors.</p>
		</article>
		
		<article class="command">
			<h1>log_message</h1>
		</article>
	</article>
	
	<article>
		<h1>Loading components</h1>
		
		<article class="command">
			<h1>lib</h1>
			
			<p><code>lib($name)</code></p>
			<p>The lib function includes the file $name.php in the application's lib directory. This is a way to declaratively include libraries, typically used in application init scripts.</p>
		</article>
		
		<article class="command">
			<h1>add_classes_dir</h1>
			<p><code>add_classes_dir($dir)</code></p>
			<p>Adds the given directory to the list of directories searched by the classes autoloader.</p>
		</article>
		
		<article class="command">
			<h1>load_ext</h1>
			
			<p><code>load_ext($name)</code></p>
			
			<p>The load_ext function is similar to the lib function except the libraries are loaded from the ext directory of the h2 distribution.</p>
			
			<p>Many modules from the hall engine were moved to the ext directory because they are in most cases optional.</p>
		</article>
		
		<article class="command">
			<h1>require_dir</h1>
			
			<p><code>require_dir($path)</code></p>
			
			<p>The require_dir function includes all PHP files in the given directory, recursing into subdirectories. Some extensions which don't fit into a single file use that function to load themselves.</p>
		</article>
	</article>
	
	<article>
		<h1>Debugging</h1>
		<article class="command">
			<h1>e</h1>
		</article>
		
		<article class="command">
			<h1>ob_destroy</h1>
		</article>
		
		<article class="command">
			<h1>msg</h1>
		</article>
		
		<article class="command">
			<h1>debug</h1>
		</article>
	</article>
	
	<article>
		<h1>Configuration</h1>
		
		<article class="command">
			<h1>setting</h1>
		</article>
	</article>

	<article>
		<h1>Request data</h1>
		<article class="command">
			<h1>vars::get</h1>
		</article>
		
		<article class="command">
			<h1>vars::post</h1>
		</article>
		
		<article class="command">
			<h1>vars::posts</h1>
		</article>
	</article>
	
	<article>
		<h1>Writing files</h1>
	
		<article class="command">
			<h1>files::save</h1>
		</article>
		
		<article class="command">
			<h1>files::get</h1>
		</article>
		
		<article class="command">
			<h1>files::append</h1>
		</article>
		
		<article class="command">
			<h1>files::time</h1>
		</article>
	</article>
	
	<article>
		<h1>Sessions</h1>
		
		<article class="command">
			<h1>user::auth</h1>
		</article>
		
		<article class="command">
			<h1>user::get_type</h1>
		</article>
		
		<article class="command">
			<h1>user::get_id</h1>
		</article>
		
		<article class="command">
			<h1>user::set_data</h1>
		</article>
		
		<article class="command">
			<h1>user::get_data</h1>
		</article>
	</article>
	
</article>

<article>
	<h1>Pages subserver</h1>
	
	<p>Pages subserver is the default subserver which serves pages creating them from templates. Templates are stored in the "pages" directory of the application directory.</p>
	
	<p>The URL path is mapped to the directories hierarchy inside the pages directory. If the request is /foo/bar, then the subserver will try to parse files pages/foo/bar.php, pages/foo/default.php, pages/foo.php, pages/default.php until one of them is found.</p>
	
	<p>The trailing part of the URL will then be converted to the "arguments" accessible through the argv function. For example, if the request /foo/bar has resulted in the file pages/foo/default.php being called, then the arguments will be "default", "bar".</p>

	<article class="command">
		<h1>add_link</h1>
		<p><code>add_link($rel, $href)</code></p>
		<p>Adds a &lt;link&gt; element to the head section of the page, with rel and href attributes set to the given values.</p>
	</article>

	<article class="command">
		<h1>add_js</h1>
		<p><code>add_js($path)</code></p>
		<p>The add_js function adds a reference to a JavaScript file. The path must be relative to the site root. References are added as &lt;script&gt; tags with the "src" attribute set to the URL inferred from the given path. The tags are added at the end of the page, before the closing &lt;/body&gt; tag.</p>
	</article>

	<article class="command">
		<h1>add_css</h1>
		<p><code>add_css($path)</code></p>
		<p>The add_css function adds a reference to a stylesheet. The given path must be reltive to the site root. This function uses the add_link function internally with $rel set to "stylesheet", but the given path is transformed into an absolute URL.</p>
	</article>
</article>

<article>
	<h1>Configuration parameters</h1>
	
	Constants
	APP_DIR
	WRITE_DIR
	SITE_ROOT
	
	
	<table class="dl">
		<tr>
			<th>Parameter</th>
			<th>Default</th>
			<th>Description</th>
		</tr>
		
		<tr>
			<td>debug</td>
			<td>0</td>
			<td>Set to 1 to enable debugging checks. This will affect every function that checks for return value of the debug function. In particular, warnings will be treated as errors.</td>
		</tr>
		
		
		<tr>
			<td>log_actions</td>
			<td>0</td>
			<td>Set to 1 to make the actions subserver write all successful actions to a log file.</td>
		</tr>
		
		<tr>
			<td>mysql_host</td>
			<td>localhost</td>
			<td></td>
		</tr>
		<tr>
			<td>mysql_user</td>
			<td></td>
			<td></td>
		</tr>
	</table>

</article>


<script src="toc.js?auto-id"></script>

</body>
</html>
