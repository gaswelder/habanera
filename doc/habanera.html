<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Habanera</title>
<link rel="stylesheet" href="doc.css">
</head>
<body>


<h1>Habanera</h1>

<section id="setup">
	<h1>Setup</h1>

	<p>This section is for those who need to install an existing site
	that uses the framework.</p>

	<section id="framework">
		<h1>Framework files</h1>

		<p>The framework itself comes as a folder that has to be copied
		somewhere with read-only permissions. It is up to the
		administrator to decide where to put the files. For example,
		the files might be put into the <code>/usr/lib/habanera</code>
		directory.</p>
	</section>

	<section id="appdir">
		<h1>Application files</h1>

		<p>The application directory contains all definitions and
		scripts for the site. Let's assume that the application is
		named "app" and will be put in the directory
		<code>/home/webapps/app</code>.</p>
	</section>

	<section id="permissions">
		<h1>Directory and file permissions</h1>

		<p>The web server process needs only read permission for the
		application files, so the entire directory may be owned by a
		different user (probably the one maintaining the site).</p>

		<p>The only exception is the "writable directory" to which the
		webserver will need to have full permissions. By default it is
		the <code>tmp</code> directory inside the application
		directory; in our example that would be
		<code>/home/webapps/app/tmp</code>. The administrator will have
		to create and explicitly grant permissions for it. The
		administrator can also redefine the write directory to be
		somewhere else, like <code>/home/webapps/app-data</code>, but
		that directory shouldn't be in the <code>/tmp</code> directory
		as the data that is written by the application can't always be
		thrown away.</p>
	</section>

	<section id="web-content">
		<h1>Static content</h1>

		<p>Static content like images, stylesheets and javascripts will
		be in the web root directory, like with the usual static sites.
		There are no specific recommendations for that expect the usual
		ones: assign the files to a different user than the webserver
		and give the server only read permissions.</p>

		<p>As with the application directory, there is one exception.
		If the site allows uploading files into directories in the web
		tree (like weblogs, for example, do), then those directories
		will have to have write permissions for the web server. It
		depends on the site which those directories are.</p>
	</section>

	<section id="entry">
		<h1>Web entry point</h1>

		<p>The entry point is the PHP script that will actually be
		called by the web server for all URLs related to the
		application. All that script has to do is to include the
		framework code and call <code>hmain</code> passing the
		application directory path as the first argument. So, in our
		example that will be:</p>

<pre>&lt;?php
require '/usr/lib/habanera/init.php';
hmain('/home/webapps/app');
?&gt;</pre>

		<p>Before calling <code>hmain</code> the script may also have
		to do some other setup operations, for example setting the
		<code>error_log</code> directive, setting the time zone or
		dealing with other idiosyncrasies of the hosting.</p>

		<p>The web server has to be configured in such a way as to call
		the script for all related URLs and serve the output. Typical
		case, especially on a shared hosting, is the Apache web server
		and <code>.htaccess</code> file with the following content:</p>

<pre>RewriteEngine	On
RewriteCond	%{DOCUMENT_ROOT}/%{REQUEST_URI} !-f
RewriteCond	%{DOCUMENT_ROOT}/%{REQUEST_URI} !-d
RewriteCond	%{REQUEST_URI}	!favicon\.ico
RewriteRule	.	index.php</pre>
	</section>
</section>

<section id="intro">
<h1>Introduction</h1>

<p>This section is for those willing to understand how the framework
functions.</p>

<section id="goal">
<h1>Goal</h1>

<p>The goal for the framework is to be as unobtrusive as possible.
There should not be demands to create special classes or files to be
able to output a simple page to the browser. Ideally, one should be
able to take a standalone PHP script and have the framework run it
without minimal changes. After that the script could be gradually
rewriten using the functions of the framework, splitting other parts
into actions or templates, and so on.</p>
</section>

<section id="concepts">
<h1>Concepts</h1>

<p>A typical site deals with two types of requests: requests that
return a page and requests that result in some action being done on the
server side, without returning any page. The second kind of requests
typically ends with a redirect to the relevant "post-action" page, so
the user sees seamless transition between pages with the action done in
between.</p>

<p>There are sites that don't make the distinction and may, for
example, process a user-submitted form and generate a page at the same
time. The user doesn't see the difference except that browsers refuse
to refresh such a page without sending the form data again. There might
be cases where such behaviour is desirable, but there are no such cases
that couldn't be reimplemented with this distinction enforced.</p>

<p>This framework implements this distinction and names the scripts
that produce pages "pages" and scripts dedicated to some work like
processing POST requests, "actions".</p>
</section>

<section id="subservers">
<h1>Subservers</h1>

<p>The framework takes requests from the web server and dispatches them
to its own "subservers". A "subserver" is a function which takes a
request object, determines if it can fulfil it, and if it can, fulfils
is.</p>

<p>The script will call all registered subservers in the order of their
registration until one of them returns <code>true</code> or there are
no more functions to call.</p>

<p>The framework itself defines the "pages" subserver and the "actions"
subserver.</p>
</section>

	<section id="pages">
		<h1>Pages</h1>

		<p>Pages subserver is the default subserver which serves pages
		creating them from templates stored in the "pages" directory of
		the application directory.</p>

		<p>The URL path is mapped to the directories hierarchy inside
		the pages directory. If the requested URL is
		<code>/foo/bar</code>, then the subserver will try to parse
		files <code>pages/foo/bar.php</code>,
		<code>pages/foo/default.php</code>, <code>pages/foo.php</code>,
		<code>pages/default.php</code> until one of them is found.</p>

		<p>The trailing part of the URL will then be converted to the
		"arguments" accessible through the <code>arg</code> function.
		For example, if the request <code>/foo/bar/42</code> has
		resulted in the file <code>pages/foo/default.php</code> being
		processed, then the arguments will be <code>"default"</code>,
		<code>"bar"</code>, and <code>"42"</code>.</p>
	</section>

	<section id="urls">
		<h1>Page URLs</h1>

		<p>There is always a "current pages directory", which is
		analogous to the current working directory, but applies only to
		page URLs. In the example above, where the file
		<code>pages/foo/default.php</code> was used to serve the page,
		current pages directory would be <code>/foo</code>.</p>

		<p>The <code>url</code> function that builds page URLs, accepts
		relative and absolute paths as its single argument. The path is
		absolute if it starts with a slash. If the path is relative,
		then current pages directory is implicitly added before it. In
		our example, the call <code>url('woe')</code> would return
		<code>/foo/woe</code> because the current pages directory would
		be <code>/foo</code>. On the other hand, the call
		<code>url('/woe')</code> would return <code>/woe</code>. This
		scheme is analogous to the usual HTTP paths convention.</p>

		<p>There is a special case, in which a site lives in a
		subdirectory of the host. If the site is served from
		<code>http://example.com/subdir/</code>, then the call
		<code>url('/')</code> will return <code>/subdir</code> instead
		of <code>/</code>. It is possible thus to deploy a complete
		site in a subdirectory without rewriting the <code>url</code>
		calls. The subdirectory <code>subdir</code> would have to be
		explicitly specified in the call to <code>hmain</code> because
		the script wouldn't be able to determine it itself.</p>
	</section>

	<section id="actions">
	<h1>Actions</h1>


	</section>

	<section id="sessions">
		<h1>User sessions</h1>

		<p>In many cases a website requires the user to be identified
		through a login form. After that the obtained credentials are
		stored in the session. Two parameters are stored: user type and
		user identifier. Although in general only the identifier would
		be enough to pull all other information from the database, the
		type is checked so often that it is practical to keep it in the
		session. Thus after the authorisation the site will call
		<code>user::auth</code> function to put user type and
		identifier in the session and then check the cached type on all
		pages that require specific type (like "admin").</p>

		<p>Another, less common but still important problem, is
		assigning multiple credentials to one user. Suppose a single
		site hosts two admin interfaces, one for editor and one for
		reviewer. There are different accounts for both roles, and
		different people are expected to be behind different roles, but
		suppose there is a person who happens to work as both. When
		that person tries to access the editor page, they are asked to
		log in and marked as an 'editor'. If after that the person goes
		to the reviews page and logs in there, they will be now marked
		as a 'reviewer' and will lose access to the editor's page.</p>

		<p>Therefore one user has to be able to log in with more than
		one different roles and keep the credentials simultaneuosly.
		Now the 'editor' page will have then first to declare that an
		'editor' is expected before checking the keys. Upon receiving
		that declaration the session system will have to see if there
		are 'editor' credentials and switch to them, or switch to null
		if there are not. The same will go to actions. If an action
		"save_review" is declared for users of type 'reviewer' and
		'big_boss', the actions subserver will try both types.</p>
	</section>

	<section id="settings">
		<h1>Settings</h1>

		<p>Some parameters may be defined in INI-files in the
		application directory. The files are loaded on demand when the
		<code>setting</code> function is first called.</p>

		<p>The default file name is <code>settings.ini</code>. Other
		files may be present to add or redefine parameters based on
		host names. If the host name is <code>foo.example.com</code>,
		then following files will be also loaded, if present, in the
		given order:</p>

		<ol>
			<li><code>settings.ini</code></li>
			<li><code>settings.com.ini</code></li>
			<li><code>settings.com.example.ini</code></li>
			<li><code>settings.com.example.foo.ini</code></li>
		</ol>
	</section>
</section>

<section id="reference" class="no-toc">
<h1>Reference</h1>

<section>
<h1>Core functions</h1>

<section class="command" id="current_url">
	<h1>The <code>current_url</code> function</h1>

	<p class="disp"><code><var>$url</var> = current_url();</code></p>

	<p>The <code>current_url</code> functions returns the URL
	that is being processed. The URL is returned as plain text,
	without HTML escaping.</p>
</section>

<section class="command" id="poparg">
	<h1>The <code>poparg</code> function</h1>

	<p class="disp"><code><var>$arg</var> = poparg()</code></p>

	<p>The <code>poparg</code> function returns next part of
	the parsed URL and shifts the base pointer one step
	further. If there are no more parts, <code>poparg</code>
	returns <code>null</code>.</p>
</section>

<section class="command">
<h1>lib</h1>

<p><code>lib($name)</code></p>

<p>The lib function includes the file $name.php in the application's
lib directory. This is a way to declaratively include libraries,
typically used in application init scripts.</p>
</section>

<section class="command">
<h1>add_classes_dir</h1>
<p><code>add_classes_dir($dir)</code></p>
<p>Adds the given directory to the list of directories searched by the
classes autoloader.</p>
</section>

<section class="command" id="load_ext">
<h1>The <code>load_ext</code> function</h1>

<p class="disp"><code>load_ext(<var>$name</var>, ...)</code></p>

<p>The <code>load_ext</code> function is similar to the
<code>lib</code> function except the libraries are loaded from the
extensions directory of the H<sub>2</sub> distribution.</p>

<p>The extensions are different from libraries in that they interact
with H<sub>2</sub> API.</p>
</section>

<section class="command" id="error">
<h1>The <code>error</code> function</h1>

<p class="disp"><code>error(<var>$message<var>);</code></p>

<p>The <code>error</code> function is equivalent to the PHP
<code>trigger_error</code> function with the level set to
<code>E_USER_ERROR</code>.</p>

<p>All generated errors are treated as fatal (unless there is a custom
errors handler that circumvents this). The <code>error</code> function
thus assumes script termination with the "Internal Server" error.</p>
</section>

<section class="command" id="warning">
<h1>The <code>warning</code> function</h1>

<p class="disp"><code>warning(<var>$message</var>);</code></p>

<p>The <code>warning</code> function is intended to report potential
errors, as opposed to the <code>error</code> function which typically
assumes that the script shouldn't continue.</p>

<p>If the <code>debug</code> parameter is set to <code>1</code>, the
<code>warning</code> function is equivalent to the <code>error</code>
function. Otherwise it just prints the message to the error log without
triggering any error handlers.</p>
</section>

<section class="command" id="log_message">
	<h1>The <code>log_message</code> function</h1>

	<p class="disp"><code>log_message(<var>$msg</var>);</code></p>

	<p>The <code>log_message</code> function writes the given message to
	the logfile <code><var>appdir</var>/log.log</code>, adding several
	context columns to it.</p>
</section>

<section class="command" id="setting">
<h1>The <code>setting</code> function</h1>

<p class="disp"><code><var>$val</var> = setting(<var>$name</var>);</code></p>

<p>The <code>setting</code> function returns the value of the
<var>name</var> parameter as defined in the corresponding settings file
in the application directory. If the parameter is not defined,
<code>null</code> is returned.</p>
</section>
</section>

	<section id="pages">
		<h1>Page functions</h1>

		<section class="command" id="set-title">
			<h1>The <code>set_title</code> function</h1>

			<p class="disp"><code>set_title(<var>$title</var>);</code></p>

			<p>The <code>set_title</code> function sets the page title
			which will be substituted in the generated HTML output in
			the <code>title</code> tag. If the template already has the
			<code>title</code> tag with a title in it, the title will
			be replaced.</p>
		</section>

		<section class="command" id="get-title">
			<h1>The <code>get_title</code> function</h1>

			<p class="disp"><code><var>$title</var> = get_title();</code></p>

			<p>The <code>get_title</code> function returns the page
			title that was set using the <code>set_title</code>
			function or <code>null</code> if the title wasn't set.</p>
		</section>

		<section class="command" id="set_page_meta">
			<h1>The <code>set_page_meta</code> function</h1>

			<p class="disp"><code>set_page_meta(<var>$name</var>, <var>$content</var>);</code></p>

			<p>The <code>set_page_meta</code> function adds a
			<code>meta</code> tag with given name and content
			attributes to the <code>head</code> section of the
			generated HTML page.</p>
		</section>

		<section class="command" id="add_link">
			<h1>The <code>add_link</code> function</h1>

			<p class="disp"><code>add_link(<var>$rel</var>, <var>$href</var>)</code></p>

			<p>The <code>add_link</code> function adds a
			<code>&lt;link&gt;</code> element to the head section of
			the page, with <code>rel</code> and <code>href</code>
			attributes set to the given values.</p>
		</section>

		<section class="command" id="add_js_css">
			<h1>The <code>add_js</code> and <code>add_css</code> functions</h1>

			<p class="disp"><code>add_js(<var>$path</var>, ...)</code></p>
			<p class="disp"><code>add_css(<var>$path</var>, ...)</code></p>

			<p>The <code>add_js</code> function adds references to
			JavaScript files as <code>script</code> tags with
			<code>src</code> attribute set to the URLs inferred from
			the given paths. The <code>script</code> tags are added at
			the end of the <code>body</code> section.</p>

			<p>The <code>add_css</code> function adds references to the
			given stylesheets as <code>link</code> tags in the
			<code>head</code> section of the generated page.</p>

			<p>The given paths must be relative to the site root. Paths
			may have query strings
			(<code>?name=val&amp;...</code>).</p>

			<p>The functions may be called at any time during the
			script execution as the page formatting and output happens
			at the end of the script.</p>
		</section>

		<section class="command" id="url_t">
			<h1>The <code>url_t</code> and <code>url</code> functions</h1>

			<p class="disp"><code><var>$url</var> = url_t(<var>$path</var>='');</code></p>

			<p class="disp"><code><var>$url</var> = url(<var>$path</var>='');</code></p>

			<p>The <code>url_t</code> function returns page URL which is a concatenation of current base URL with the given path.</p>

			<p>For example, if current URL is
			<code>example.net/one/two</code> and the page script is
			<code>pages/foo/bar.php</code>, then
			<code>url('zwei/drei')</code> will return
			<code>example.net/one/zwei/drei</code>.</p>
		</section>

		<section class="command" id="template">
			<h1>The <code>template</code> function</h1>

			<p class="disp"><code><var>$str</var> = template(<var>$name</var>, <var>$vars</var>=array());</code></p>

			<p>The <code>template</code> function returns the result of
			parsing the file <code><var>$name</var>.t</code> in the
			directory of the current page script as PHP file with
			variables <var>vars</var> in context.</p>
		</section>
	</section>

	<section id="actions">
		<h1>Actions</h1>

		<section class="command" id="declare_action">
			<h1>The <code>declare_action</code> function</h1>

			<p class="disp"><code>declare_action(<var>$name</var>,
			<var>$users</var>, <var>$func</var>);</code></p>

			<p>The <code>declare_action</code> function declares an
			action <var>name</var> and assigns <var>func</var> as the
			action function and <var>users</var> as the list of types
			of uses who can call that action. The <var>users</var>
			variable should contain a comma-separated list of user
			types.</p>

			<p>As all users have at least the <code>guest</code> credentials, specifying <code>"guest"</code> as <var>users</var> will allow everyone to run the action.</p>

			<p>If the user has credentials of more than one type from
			the list, the first such credentials will be used. Thus,
			the action <code>foo</code> in the example below will be
			run with the <code>customer</code> identity for authorized
			customers, and with the <code>guest</code> identity for
			everyone else:</p>

<pre>declare_action('foo', 'customer, guest', function() {
	...
});</pre>
		</section>

		<section class="command" id="last_action">
			<h1>The <code>last_action</code> function</h1>

			<p class="disp"><code><var>$name</var> = last_action();</code></p>

			<p>The <code>last_action</code> function returns name of
			the preceding action after which the user was redirected to
			the current page. The function returns <code>null</code> if
			there was no preceding action.</p>
		</section>

		<section class="command" id="action_result">
			<h1>The <code>action_result</code> function</h1>

			<p class="disp"><code><var>$ok</var> = action_result();</code></p>

			<p>The <code>action_result</code> function returns <code>true</code> if the preceding action was successful, <code>false</code> if it returned one or more errors, and <code>null</code> if there was no action.</p>
		</section>

		<section class="command" id="action_errors">
			<h1>The <code>action_errors</code> function</h1>

			<p class="disp"><code><var>$errors</var> = action_errors();</code></p>

			<p>The <code>action_errors</code> function returns an array of errors returned by the preceding action. If there was no action, an empty array is returned.</p>
		</section>

		<section class="command" id="aurl">
			<h1>The <code>aurl</code> and <code>aurl_t</code> functions</h1>

			<p class="disp"><code><var>$url</var> = aurl_t(<var>$name</var>,
				<var>$ok_url</var>=null, <var>$fail_url</var>=null);</code></p>

			<p class="disp"><code><var>$url</var> = aurl(<var>$name</var>,
				<var>$ok_url</var>=null, <var>$fail_url</var>=null);</code></p>

			<p>The <code>aurl_t</code> function returns the URL of the
			action <var>name</var> which will redirect back to URL
			<var>ok_url</var> on success or to URL <var>fail_url</var>
			on error. If <var>ok_url</var> or <var>fail_url</var> are
			null, the URL of the current page is assumed.</p>

			<p>The <code>aurl</code> function is the same as
			<code>aurl_t</code> except the returned URL is escaped to
			be used in HTML output.</p>
		</section>

		<section class="command" id="action_button">
		<h1>The <code>action_button</code> function</h1>

		<p class="disp"><code><var>$htm</var>
			= action_button(<var>$title</var>,
			<var>$action_name</var>,
			<var>$args</var>,
			<var>$ok_url</var>=null,
			<var>$fail_url</var>=null);</code></p>

		<p>The <code>action_button</code> function returns HTML code for a form
		with submit button that directs the user to the action URL
		<code>url_t(<var>$action_name</var>, <var>$ok_url</var>,
		<var>$fail_url</var>)</code> passing values given in the associative
		array <var>$args</var> as POST parameters.</p>
		</section>

		<section class="command" id="ini-log_actions">
		<h1>The <code>log_actions</code> parameter</h1>

		<p class="disp"><code>log_actions = 0</code></p>

		<p>If set to a nonzero value, each action will be logged.</p>
		</section>
	</section>


	<section>
		<h1>HTTP header functions</h1>

		<section class="command" id="req_header">
		<h1>The <code>req_header</code> function</h1>

		<p class="disp"><code><var>$value</var> =
		req_header(<var>$name</var>);</code></p>

		<p>The <code>req_header</code> function returns the value of the
		request header <var>$name</var>, if one is given by the client, or
		<code>null</code> if not.</p>
		</section>

		<section class="command" id="http_status">
		<h1>The <code>http_status</code> function</h1>

		<p class="disp"><code>http_status(<var>$code</var>)</code></p>

		<p>The <code>http_status</code> function adds to the output an HTTP
		status header corresponding to the given HTTP status code.</p>

		<p>This function is intended for extensions, like the images subserver,
		that need more control over the headers.</p>
		</section>

		<section class="command" id="redirect">
			<h1>The <code>redirect</code> function</h1>

			<p class="disp"><code>redirect(<var>$url</var>,
				<var>$code</var>=302);</code></p>

			<p>The <code>redirect</code> function writes appropriate
			HTTP headers to the output to redirect the browser to the
			given URL and stops the script execution.</p>

			<p>By default the redirect is done with the <code>302
			Found</code> HTTP status. The <var>code</var> variable may
			specify another code, like <code>303</code> for <code>See
			Other</code> or <code>307</code> for <code>Temporary
			Redirect</code> status.</p>

			<p>Note that the <code>302</code> status code is
			practically ambiguous due to historically incorrect
			implementation by many browsers. The <code>303</code> and
			<code>307</code> codes should be used when specific
			behaviour is needed.</p>
		</section>

		<section class="command">
			<h1>The <code>error_</code> functions</h1>

			<p><code>error_&lt;<i>type</i>&gt;()</code></p>

			<p>The error_* functions output corresponding HTTP status header and error page.</p>

			<table>
				<tr>
					<th>Function</th>
					<th>HTTP&nbsp;code</th>
					<th>Meaning</th>
				</tr>
				<tr>
					<td><code>error_bad_request</code></td>
					<td>400</td>
					<td></td>
				</tr>
				<tr>
					<td>error_forbidden</td>
					<td>403</td>
					<td>Access denied. The client probably has to login.</td>
				</tr>
				<tr>
					<td>error_notfound</td>
					<td>404</td>
					<td>Could not find the requested page.</td>
				</tr>
				<tr>
					<td>error_gone</td>
					<td>410</td>
					<td>The page was removed.</td>
				</tr>
				<tr>
					<td>error_server</td>
					<td>500</td>
					<td>We screwed up.</td>
				</tr>
			</table>
		</section>

		<section class="command">
			<h1>announce_*</h1>
			announce_json($charset='UTF-8')
			announce_txt($charset='UTF-8')
			announce_html($charset='UTF-8')
		</section>

		<section class="command">
			<h1>announce_file</h1>
			<p><code>announce_file($filename, $size=null)</code></p>
		</section>
	</section>

	<section id="debug">
		<h1>Debugging</h1>

		<section class="command">
			<h1>ob_destroy</h1>

			<p>Discards all buffered output. This can be used to
			prevent other output from hiding debug messages.</p>
		</section>

		<section class="command" id="e">
			<h1>e</h1>

			<p class="disp"><code>e(<var>$var</var>);</code></p>

			<p>Calls ob_destroy, var_dump($var) and exit.</p>
		</section>

		<section class="command">
			<h1>The <code>debug</code> parameter</h1>

			<p>If set to 1, all warnings are treated as errors.</p>
		</section>
	</section>

	<section>
		<h1>Request data</h1>
		<section class="command">
			<h1>vars::get</h1>
		</section>

		<section class="command">
			<h1>vars::post</h1>
		</section>

		<section class="command">
			<h1>vars::posts</h1>
		</section>
	</section>

	<section id="uploads">
		<h1>File uploads</h1>

		<section class="command" id="uploaded_files">
			<h1>The <code>uploaded_files</code> function</h1>

			<p class="disp"><code><var>$files</var> = uploaded_files(<var>$input_name</var>)</code></p>

			<p>The <code>uploaded_files</code> function returns descriptions of uploaded files stored in the <code>$_FILES</code> global array under the index <var>$input_name</var>, converting the single-file case to the general multiple-files form. Each element of the <var>$files</var> array is an associative array with fields <code>name</code>, <code>type</code>, <code>tmp_name</code>, <code>size</code> and <code>error</code>.</p>
		</section>

		<section class="command" id="accept_uploads">
			<h1>The <code>accept_uploads</code> function</h1>

			<p class="disp"><code><var>$paths</var> = accept_uploads(<var>$input_name</var>, <var>$dirpath</var>)</code></p>

			<p>The <code>accept_uploads</code> function processes the uploaded files using <var>$input_name</var> as index to the <code>$_FILES</code> global array, moves all uploaded files to the directory <var>$dirpath</var> assigning them random names and returns an array of paths to the new files.</p>
		</section>

		<section class="command" id="log_uploads">
			<h1>The <code>log_uploads</code> parameter</h1>

			<p class="disp"><code>log_uploads = 0</code></p>

			<p>If set to <code>1</code>, then a message will be written
			to the log file for each saved uploaded file.</p>
		</section>
	</section>

	<section>
		<h1>Writing files</h1>

		<section class="command">
			<h1><code>files::save</code></h1>

			<p class="disp"><code><var>$ok</var> = files::save(<var>$dir</var>, <var>$name</var>, <var>$contents</var>)</code></p>

			<p>Saves given contents to the file named <var>$name</var> in the directory <var>$dir</var>.</p>
		</section>

		<section class="command">
			<h1>files::get</h1>
		</section>

		<section class="command">
			<h1>files::append</h1>
		</section>

		<section class="command">
			<h1>files::time</h1>
		</section>
	</section>

	<section id="user">
		<h1>Session control</h1>

		<section class="command" id="user-auth">
			<h1>The <code>user::auth</code> function</h1>

			<p class="disp"><code>user::auth(<var>$type</var>, <var>$id</var>=null);</code></p>

			<p>The <code>auth</code> function adds the pair
			(<var>type</var>, <var>id</var>) to the user's list of
			credentials. The identifier is secondary to the user type
			and may be omitted.</p>

			<p>If there is a pair with the same type, it is replaced.
			All the additional data related to the discarded pair is
			cleared.</p>
		</section>

		<section class="command" id="user-transfer">
			<h1>The <code>user::transfer</code> function</h1>

			<p class="disp"><code>user::transfer(<var>$type</var>);</code></p>

			<p>The <code>user::transfer</code> function allows to move all session data associated with the guest identity to another identity of the given type.</p>

			<p>This might be needed, for example, to preserve the shopping cart a user has created before logging in. In that case the authorisation might look like:</p>

<pre class="disp"><i>(...check login data...)</i>
// Add new identity
user::auth('customer', 42);
// Move the session data to the new identity
user::transfer('customer');</pre>
		</section>

		<section class="command" id="user-select">
			<h1>The <code>user::select</code> function</h1>

			<p class="disp"><code><var>$ok</var> =
				user::select(<var>$type</var>);</code></p>

			<p>The <code>user::select</code> function selects the pair
			with the given type from the current user's credentials, if
			such exists, and returns <code>true</code> on success or
			<code>false</code> on failure.</p>

			<p>Applications typically call <code>user::select</code> to
			check that the user was authorized as a particular type and
			to get other values attached to that type using
			<code>user::id</code> and <code>user::get</code>.</p>

<pre class="disp">// Check that the user is an editor
if(!user::select('editor')) {
	error_forbidden("Only editors can view this");
}

// Use session data associated with the editor credentials
$id = user::get('last-article');
if($id) {
	redirect(url_t("articles/$id"));
}
...</pre>
		</section>

		<section class="command" id="user-clear">
			<h1>The <code>user::clear</code> function</h1>

			<p class="disp"><code>user::clear(<var>$type</var>);</code></p>

			<p>The <code>user::clear</code> function removes the
			credentials pair with the given type along with additional
			data that might be attached to it.</p>

			<p>In other words, this is the logout function.</p>
		</section>

		<section class="command" id="user-type">
			<h1>The <code>user::type</code> function</h1>

			<p class="disp"><code><var>$type</var> = user::type();</code></p>

			<p>The <code>type</code> function returns the type of the user's current identity.</p>
		</section>

		<section class="command" id="user-id">
			<h1>The <code>user::id</code> function</h1>

			<p class="disp"><code><var>$id</var> = user::id();</code></p>

			<p>The <code>id</code> function returns the identifier of the user's current identity.</p>
		</section>

		<section class="command" id="user-set">
			<h1>The <code>user::set</code> function</h1>
		</section>

		<section class="command" id="user-get">
			<h1>The <code>user::get</code> function</h1>
		</section>
	</section>

	<section>
	<h1>Functions for writing extensions</h1>

		<section class="command">
		<h1>The <code>add_subserver</code> function</h1>

		<p><code>add_subserver($func)</code></p>

		<p>The <code>add_subserver</code> function adds the function <var>func</var> to a list of request processing functions. The <var>func</var> function must have form:</p>

		<p><code>$ok = $func($request)</code>.</p>

		<p>If the function <var>func</var> will be called, it will receive a request object <var>request</var> and will have to determine whether to process it. If the function recognises the request and processes it, it must return <code>true</code>.</p>
		</section>

		<section class="command" id="on_error">
		<h1>The <code>on_error</code> function</h1>

		<p class="disp"><code>on_error(<var>$func</var>);</code></p>

		<p>The <code>on_error</code> function adds the given function <var>$func</var> to the list of functions called when errors occur. The last added function will be called first.</p>

		<p>The function <var>func</var> must have form:</p>

		<p class="disp"><code><var>$ok</var> = <var>$func</var>(<var>$msg</var>, <var>$line</var>);</code></p>

		<p class="cont">where <var>$msg</var> is an error message and <var>$line</var> is a string in form "<var>file&nbsp;path</var>:<var>line&nbsp;number</var>" specifying where the error occured.</p>

		<p>If <var>$func</var> returns <code>true</code>, the rest of the error functions will not be called.</p>
		</section>
	</section>
</section>

<section id="extensions">
	<h1>Extensions</h1>

	<section id="ext_debug">
		<h1>The <code>ext_debug</code> extension</h1>

		<p>The <code>ext_debug</code> extension catches all errors and outputs execution stacks terminating the script. It does nothing if the <code>debug</code> parameter is not set to <code>1</code>.</p>
	</section>

	<section id="images">
		<h1>The images subserver</h1>

		<p>This subserver generates image previews from original full-sized image files stored on disk. This task is typical for shops, blogs and other sites dealing with image files of different sizes uploaded by users.</p>

		<p>The original image is served by the web server itself. But if the same image path is "decorated" with a size marker, then the subserver serves the resized version of that image, creating it in cache if needed. The decorated URLs are created by the <code>image_url</code> function.</p>

		<p>The subserver supports caching by browsers using the <code>ETag</code> and related HTTP headers.</p>

		<p>There is a hard size limit for the images that can be
		processed that is set to 2&nbsp;megabytes. If the original
		image exceeds that size, then all requests to the resized
		copies will return the "Not Found" error, since there will be
		no actual copies, and a warning will be written in the errors
		log.</p>

		<section class="command" id="image_url">
			<h1>The <code>image_url</code> function</h1>

			<p class="disp"><code><var>$url</var> = image_url(<var>$imgpath</var>, <var>$width</var>=null, <var>$height</var>=null);</code></p>

			<p>The <code>image_url</code> function creates the URL for the copy of the image found at <var>imgpath</var> with width limited to <var>$width</var> pixels and height limited to <var>$height</var> pixels.</p>

			<p>Both <var>width</var> and <var>height</var> are optional. If none of the limits is given, the original URL is returned.</p>

			<p>The created copy is never enlarged. If the original size is less than the given limits, the original URL will be returned.</p>
		</section>

		<section class="command" id="imgcache">
			<h1>The <code>imgcache</code> parameter</h1>

			<p>The <code>imgcache</code> parameter defines the path to the directory where preview copies of images will be stored. If the parameter is not defined, then <code><var>WRITE_DIR</var>/image-previews</code> is assumed.</p>

			<p>Regardless of the path the script must have write permissions for that directory. If the directory doesn't exist, the script must be able to create it.</p>
		</section>

	</section>

	<section id="ext-lang">
		<h1>The <code>lang</code> extension</h1>

		<p>The <code>lang</code> extension is a simpler alternative to
		<code>gettext</code>. It may be chosen for smaller sites where
		setting up <code>gettext</code> wouldn't give much advantage or
		on hostings where <code>gettext</code> isn't available or
		doesn't work properly.</p>

		<section id="lang-name-format">
			<h1>Language identifier format</h1>

			<p>The functions that accept a <var>lang</var> argument
			expect it to be in the HTTP <code>accept-language</code>
			format, which is:</p>

			<p class="disp"><code>1*8ALPHA *( "-" 1*8ALPHA)</code></p>

			<p>Examples are <code>en</code>, <code>en-GB</code>,
			<code>my-funky-dialect</code>.</p>
		</section>

		<section id="lang-file-format">
			<h1>Translation files</h1>

			<p>Translation file for language <var>lang</var> is
			<code><var>appdir</var>/lang/&lt;lowecase(<var>lang)&gt;</code>.
			That is, translation file for language <code>en-GB</code>
			would be <code><var>appdir</var>/lang/en-gb</code>.</p>

			<p>The file format is plain text with a repeated sequence
			of lines: (message line, translation line, empty line). An example would be:</p>

<pre>Hello
Hey man

How do you do?
Wassup?

Popular items
Funky stuff
</pre>
		</section>

		<section class="command" id="lang-lookup">
			<h1>The <code>t</code> and <code>lang::lookup</code> functions</h1>

			<p class="disp"><code><var>$trans</var> =
				t(<var>$msg</var>, <var>$lang</var>=null);</code></p>
			<p class="disp"><code><var>$trans</var> =
				lang::lookup(<var>$msg</var>, <var>$lang</var>=null);</code></p>

			<p><code>t</code> is an alias of <code>lang::lookup</code>.
			The function returns the translation for <var>msg</var> or
			<var>msg</var> itself if there is no translation. The
			translation file for the corresponding language is loaded
			on demand. If <var>lang</var> is omitted, the default
			language is assumed.</p>
		</section>

		<section class="command" id="lang-have">
			<h1>The <code>lang::have</code> function</h1>

			<p class="disp"><code><var>$exists</var> =
				lang::have(<var>$lang</var>);</code></p>

			<p>The <code>have</code> function returns <code>true</code>
			if there is a translation file for language <var>lang</var>
			and <code>false</code> otherwise.</p>
		</section>

		<section class="command" id="lang-set">
			<h1>The <code>lang::set</code> function</h1>

			<p class="disp"><code>lang::set(<var>$lang</var>);</code></p>

			<p>The <code>set</code> function sets default language for
			lookups to <var>lang</var>.</p>
		</section>

		<section class="command" id="lang-get">
			<h1>The <code>lang::get</code> function</h1>

			<p class="disp"><code><var>$lang</var> = lang::get();</code></p>

			<p>The <code>get</code> function returns the default
			language name used for lookups.</p>
		</section>

		<section class="command" id="param-lang">
			<h1>The <code>lang</code> setting</h1>

			<p>The <code>lang</code> parameter may be defined in
			settings files to set the default language as alternative
			to calling <code>lang::set</code> in the
			<code>init.php</code> file.</p>
		</section>
	</section>
</section>

<script src="toc.js"></script>

</body>
</html>
